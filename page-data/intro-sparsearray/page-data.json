{"componentChunkName":"component---src-templates-blog-post-js","path":"/intro-sparsearray/","result":{"data":{"site":{"siteMetadata":{"title":"Blog.kt"}},"markdownRemark":{"id":"08ed1263-759b-5215-b528-844e800d39bc","excerpt":"基础原理 SparseArray 其实代码非常简短： 两个数组，一个保存 key，另一个保存 value 存取数据时，通过对 key 数组二分查找拿到 index，然后返回 value 数据中的值 据此我们可以知道，SparseArray…","html":"<h2>基础原理</h2>\n<p>SparseArray 其实代码非常简短：</p>\n<ol>\n<li>两个数组，一个保存 key，另一个保存 value</li>\n<li>存取数据时，通过对 key 数组二分查找拿到 index，然后返回 value 数据中的值</li>\n</ol>\n<p>据此我们可以知道，SparseArray 内存占用是 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span></span>（忽略单独对象、基础类型所占用空间，仅考虑数据规模），那么这样会比 HashMap 更省内存吗？</p>\n<h2>内存优势</h2>\n<ol>\n<li>避免自动装箱</li>\n<li>不需要额外存储 <code class=\"language-text\">next</code> 对象的引用</li>\n</ol>\n<p>虽然自动装箱的值范围只要仍在 JVM 缓存范围内，JVM 就会优化为基础类型，但是避免自动装箱总是性能更优的选择。</p>\n<p>内存方面，自动装箱会带来额外的内存占用。在 64bit 的 JVM 上，基础类型 <code class=\"language-text\">int</code> 将占用 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">4 Bytes</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">4</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">es</span></span></span></span></span> 的内存，而一个（未缓存的） <code class=\"language-text\">Integer</code> 将占据 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>16</mn><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">16 Bytes</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">16</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">es</span></span></span></span></span>。这是 4 倍的内存占用。</p>\n<p>接着说说第二点，HashMap 每个元素都是一个 Node 对象：</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">K</span> key<span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">V</span> value<span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> next<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//...</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>暂时不论 Node 本身所占据的空间，单单其内部拥有 <code class=\"language-text\">hash</code>，<code class=\"language-text\">key</code>，<code class=\"language-text\">value</code> 和 <code class=\"language-text\">next</code> 四个成员变量。可以保守地说 HashMap 的空间占用至少是 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">4n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span><span class=\"mord mathnormal\">n</span></span></span></span></span>。</p>\n<p>此处仅做数据规模举例，详细内存比较可以参见： <a href=\"https://stackoverflow.com/questions/25560629/sparsearray-vs-hashmap\">SparseArray vs HashMap</a>。</p>\n<h2>劣势</h2>\n<p>SparseArray 存取数据时，需要对整个 Key 数组进行二分查找，时间复杂度为 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(logn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>）。数据量较大的时候，存取性能明显弱于 <code class=\"language-text\">HashMap</code>。因为 <code class=\"language-text\">HashMap</code> 存储了 <code class=\"language-text\">hash</code> 作为 Value 索引位置，存取数据都是 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>。</p>\n<h2>总结</h2>\n<p>SparseArray 的设计思路就是时间换空间。通过每次存取时的二分查找，来代替复杂的数据结构带来的内存占用，这十分贴切移动端数据量低的处理场景。SparseArray 不止于上述优化手段，其内部还是用了 <code class=\"language-text\">DELETE</code> 对象来标志被删除的 value，达到索引复用的效果，以降低数组扩容/缩减的频率。</p>\n<hr>\n<ul>\n<li><a href=\"https://tech.meituan.com/2016/06/24/java-hashmap.html\">Java 8系列之重新认识HashMap</a></li>\n<li><a href=\"https://stackoverflow.com/questions/8419860/integer-vs-int-with-regard-to-memory\">Integer vs int: with regard to memory</a></li>\n<li><a href=\"https://stackoverflow.com/questions/41314160/java-8-hashmap-high-memory-usage\">Java 8 hashmap high memory usage</a></li>\n<li><a href=\"https://stackoverflow.com/questions/258120/what-is-the-memory-consumption-of-an-object-in-java\">What is the memory consumption of an object in Java?</a></li>\n</ul>","frontmatter":{"title":"SparseArray 简介","date":"2021-07-23","description":null,"excerpt":null}},"previous":{"fields":{"slug":"gradle-daemon-and-oom-in-jenkins"},"frontmatter":{"title":"Gradle daemon 与 OOM"}},"next":{"fields":{"slug":"custom-viewgroup-1-cons-and-pros"},"frontmatter":{"title":"自定义布局其一：优劣势与使用场景"}}},"pageContext":{"id":"08ed1263-759b-5215-b528-844e800d39bc","previousPostId":"e2a19553-98dd-5719-b4e0-a87ec483b31b","nextPostId":"618511a2-87a9-5d86-bd57-43667df94782"}},"staticQueryHashes":["2082311839","2355076697","959449634"],"slicesMap":{}}