{"componentChunkName":"component---src-templates-blog-post-js","path":"/java-threads-vs-android-asynctask-which-to-use/","result":{"data":{"site":{"siteMetadata":{"title":"Blog.kt"}},"markdownRemark":{"id":"b495f636-1b4e-5d95-9ad8-27bad118b4eb","excerpt":"本文发布于我的博客 此文章为「译文」，原文链接：http://www.mergeconflict.net/2012/05/java-threads-vs-android-asynctask-which.html 翻译已获原作者授权。水平有限，如有缺漏，恳请指正，谢谢~ 前言 在 Android…","html":"<blockquote>\n<p>本文发布于<a href=\"https://blog.rosuh.me/2018/05/java-threads-vs-android-asynctask-which-to-use/\">我的博客</a></p>\n<p>此文章为「译文」，原文链接：<a href=\"http://www.mergeconflict.net/2012/05/java-threads-vs-android-asynctask-which.html\">http://www.mergeconflict.net/2012/05/java-threads-vs-android-asynctask-which.html</a></p>\n<p>翻译已获原作者授权。水平有限，如有缺漏，恳请指正，谢谢~</p>\n</blockquote>\n<h1>前言</h1>\n<p>在 Android 开发中，有一个非常重要但是较少被讨论到的问题：UI 的响应。这个问题一部分由 Android 系统本身决定，但更多时候是还是开发者的责任。抛开其他问题而言，解决 Android 应用 UI 响应问题的关键，就是尽可能地让大部分耗时工作转移到后台执行。众所周知，将耗时任务或是 CPU 密集型任务放到后台运行的方法，基本上只有两个：</p>\n<ul>\n<li>Java Thread</li>\n<li>Android 原生<code class=\"language-text\">AsyncTask</code>辅助类</li>\n</ul>\n<p>两者不一定能分出个孰优孰劣，因此了解他们各自的使用场景，对您的优化性能是有一定的好处的。</p>\n<h2>AsyncTask 的使用场景</h2>\n<ul>\n<li>不需要下载大量数据的简单网络操作</li>\n<li>I/O 密集型任务，耗时可能几个毫秒以上</li>\n</ul>\n<h2>Java Thread 使用场景</h2>\n<ul>\n<li>涉及中等或大量的网络数据操作（包括上传和下载）</li>\n<li>需要在后台执行的 CPU 密集型任务</li>\n<li>当你想要在 UI 线程控制 CPU 占用率时</li>\n</ul>\n<p>还有一个老生常谈的问题就是，千万不要在 UI 线程（主线程）执行网络操作。你需要使用上述两种方式之一来访问网络。</p>\n<h1>关键点</h1>\n<p>Java Thread 和 <code class=\"language-text\">AsyncTask</code>最关键的不同点在于，<code class=\"language-text\">AsyncTask</code>运行在 GUI 线程¹  上，所以繁重的 CPU 任务都可能导致 UI 响应性下降。Java Thread  可以拥有不同的线程优先级，使用低优先级的线程来完成非实时运算任务能够很好地为 GUI 操作释放 CPU 时间。这是提高 GUI 响应性的关键点之一。</p>\n<p>然而，正如很多 Android 开发者所了解的，你无法在后台线程更新 UI 组件，不然就会抛出异常。这对于 <code class=\"language-text\">AsyncTask</code>来说并不是什么大事² ，但是当你使用的是 Java Thread，那么你必须在你操作结束的时候使用<code class=\"language-text\">post()</code>来更新 UI³ 。</p>\n<hr>\n<p>译者按原文查找资料注：</p>\n<ol>\n<li><code class=\"language-text\">AsyncTask</code>必须在主线程加载，其中除了<code class=\"language-text\">doInBackground(Object [])</code>方法外，其余三个方法都在 UI 线程运行</li>\n<li>基于第一点，<code class=\"language-text\">AsyncTask</code>可以在其余三个方法中更新 UI 组件</li>\n<li>可以使用<code class=\"language-text\">view.post()</code>方法来更新 UI 组件，这个方法和使用<code class=\"language-text\">Activity.runOnUiThread()</code>方法区别不大</li>\n</ol>\n<p><em>参看</em>：</p>\n<ul>\n<li><a href=\"http://www.mergeconflict.net/2012/05/java-threads-vs-android-asynctask-which.html\">Java threads vs. Android AsyncTask: Which to use?</a></li>\n<li><a href=\"https://developer.android.com/reference/android/os/AsyncTask\">AsyncTask Android Developers</a></li>\n<li><a href=\"https://stackoverflow.com/questions/4369537/update-ui-from-thread\">Update UI from Thread</a></li>\n<li><a href=\"https://stackoverflow.com/questions/10558208/android-whats-the-difference-between-activity-runonuithread-and-view-post\">Android: What’s the difference between Activity.runOnUiThread and View.post?</a></li>\n</ul>","frontmatter":{"title":"「译」Java Thread vs AsyncTask：该用哪个？","date":"2018-05-15","description":"在 Android 开发中，有一个非常重要但是较少被讨论到的问题：UI 的响应。这个问题一部分由 Android 系统本身决定，但更多时候是还是开发者的责任。抛开其他问题而言，解决...","excerpt":null}},"previous":{"fields":{"slug":"using-viewpager-to-make-a-banner-2"},"frontmatter":{"title":"手动实现轮播图（二）：循环滚动、定时切换与指示器"}},"next":{"fields":{"slug":"implement-a-star-in-Java"},"frontmatter":{"title":"A*（A星） 算法 Java 实现"}}},"pageContext":{"id":"b495f636-1b4e-5d95-9ad8-27bad118b4eb","previousPostId":"4fe4a600-22a5-5462-bb77-0e126f0c47c5","nextPostId":"5340f77d-656d-5174-b123-4eeb1edaf3be"}},"staticQueryHashes":["2082311839","2355076697","959449634"],"slicesMap":{}}